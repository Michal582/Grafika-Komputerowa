<!DOCTYPE html>
<html>
<head>
    <title>Zaliczenie</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <script>
        // Inicjalizacja sceny, kamery i renderera
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowMap.autoUpdate = false;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Tworzenie geometrii podłogi
        const width = 5;
        const length = 200;
        const height = 0.01;
        const textureRepeatX = 7; // Liczba powtórzeń tekstury wzdłuż osi X
        const textureRepeatY = 100; // Liczba powtórzeń tekstury wzdłuż osi Y

        const geometryFloor = new THREE.BoxGeometry(width, height, length);
        geometryFloor.faceVertexUvs[0][0][0].set(0, 0);
        geometryFloor.faceVertexUvs[0][0][2].set(textureRepeatX, 0);
        geometryFloor.faceVertexUvs[0][0][1].set(0, textureRepeatY);
        geometryFloor.faceVertexUvs[0][1][0].set(0, textureRepeatY);
        geometryFloor.faceVertexUvs[0][1][2].set(textureRepeatX, 0);
        geometryFloor.faceVertexUvs[0][1][1].set(textureRepeatX, textureRepeatY);

        const textureFloor = new THREE.TextureLoader().load('road.jpg');
        textureFloor.wrapS = THREE.RepeatWrapping;
        textureFloor.wrapT = THREE.RepeatWrapping;
        textureFloor.repeat.set(textureRepeatX, textureRepeatY);

        const materialFloor = new THREE.MeshBasicMaterial({ map: textureFloor });
        const floor = new THREE.Mesh(geometryFloor, materialFloor);
        floor.position.y = -height / 2; // Obniż podłogę o połowę jej wysokości
        floor.castShadow = true;
        floor.receiveShadow = true;
        scene.add(floor);

        // Tworzenie geometrii nieba
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const textureSky = new THREE.TextureLoader().load('xd.jpg');
        const materialSky = new THREE.MeshBasicMaterial({ map: textureSky, side: THREE.BackSide });
        const sky = new THREE.Mesh(skyGeometry, materialSky);
        scene.add(sky);

        // Dodanie słońca
        const circleRadius = 2;
        const circleHeight = 0.1;
        const circleGeometry = new THREE.SphereGeometry(circleRadius, 32, 32);
        const circleMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
        const circle = new THREE.Mesh(circleGeometry, circleMaterial);
        circle.position.y = 20; // Wysokość okręgu nad drogą
        circle.castShadow = true;
        scene.add(circle);

        // Dodanie prostokątnego słupek przy drodze
        const postWidth = 0.2;
        const postHeight = 1;
        const postLength = 0.2;

        const geometryPost = new THREE.BoxGeometry(postWidth, postHeight, postLength);
        const materialPost = new THREE.MeshBasicMaterial({ color: 0x654321 });
        const post = new THREE.Mesh(geometryPost, materialPost);
        post.position.set(0, postHeight / 2, -length / 4); // Ustawienie pozycji słupka przy drodze
        post.castShadow = true; // Ustawienie słupka jako obiektu rzutującego cień
        scene.add(post);

        // Ustawienie pozycji kamery
        const cameraHeight = 1; // Wysokość kamery nad podłogą
        camera.position.set(0, cameraHeight, 0);

        // Inicjalizacja ruchu kamery
        const cameraSpeed = 0.1;
        const keyboardState = {};
        const mouseState = { x: 0, y: 0 };
        let headRotationY = 0;
        let isMousePressed = false;

        function handleKeyDown(event) {
            keyboardState[event.code] = true;
        }

        function handleKeyUp(event) {
            keyboardState[event.code] = false;
        }

        function handleMouseMove(event) {
            if (isMousePressed) {
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                const sensitivity = 0.002;

                headRotationY -= movementX * sensitivity;
                const headRotationX = camera.rotation.x - movementY * sensitivity;

                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, headRotationX));
                camera.rotation.y = headRotationY;
            }
        }

        function handleMouseDown(event) {
            if (event.button === 0) {
                isMousePressed = true;
            }
        }

        function handleMouseUp(event) {
            if (event.button === 0) {
                isMousePressed = false;
            }
        }

        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mouseup', handleMouseUp);

        function updateCameraPosition() {
            if (keyboardState['KeyW'] || keyboardState['ArrowUp']) {
                camera.position.add(camera.getWorldDirection().multiplyScalar(cameraSpeed));
            }
            if (keyboardState['KeyS'] || keyboardState['ArrowDown']) {
                camera.position.add(camera.getWorldDirection().multiplyScalar(-cameraSpeed));
            }
            if (keyboardState['KeyA'] || keyboardState['ArrowLeft']) {
                camera.position.add(camera.getWorldDirection().cross(new THREE.Vector3(0, 1, 0)).normalize().multiplyScalar(-cameraSpeed));
            }
            if (keyboardState['KeyD'] || keyboardState['ArrowRight']) {
                camera.position.add(camera.getWorldDirection().cross(new THREE.Vector3(0, 1, 0)).normalize().multiplyScalar(cameraSpeed));
            }

            // Ograniczenie ruchu kamery na boki do szerokości drogi
            const maxCameraX = width / 2 - 0.5;
            camera.position.x = Math.max(-maxCameraX, Math.min(maxCameraX, camera.position.x));
            // Ograniczenie ruchu kamery wzdłuż osi Y
            camera.position.y = Math.max(cameraHeight, camera.position.y);
            // Ograniczenie ruchu kamery w głąb drogi
            const maxCameraZ = length / 2 - 0.5;
            camera.position.z = Math.max(-maxCameraZ, Math.min(maxCameraZ, camera.position.z));

            // Sprawdzanie, czy użytkownik doszedł do końca drogi
            const endPositionZ = length / 5 - 1;
            if (camera.position.z >= endPositionZ) {
                camera.position.z = -endPositionZ;
            }
        }

        // Dodanie słońca jako źródła światła
        const sun = new THREE.PointLight(0xffffff, 1, 100);
        sun.position.set(0, 50, -50);
        sun.castShadow = true;
        scene.add(sun);

        renderer.shadowMap.needsUpdate = true;
        floor.receiveShadow = true;
        circle.castShadow = true;
        post.castShadow = true;

        // Animacja
        function animate() {
            requestAnimationFrame(animate);
            updateCameraPosition();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
